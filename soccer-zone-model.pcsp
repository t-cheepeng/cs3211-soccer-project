// TODO List (In order of priority, Highest -> Lowest):
// 1. Have some C# Helper class to check all the defined things. ABSTRACTION
// 2. Model failures of shoot, dribble, run and pass
// 3. Model backward actions 
// 4. Assign probabilities to success/failure. Probably do this with a C# Helper class again
// 5. Expand to larger number of zones and larger number of players

// Model
// =============================
// |             |             |             
// |      0      |      1      |
// |             |             |
// =============================
// Instead of modelling players, we model zones on the field
// Each zone can have any number of players from either team
// Two Players only
// No goalkeeper
// Players are not allowed to perform actions backwards(ie. all actions move in one direction, from 0 -> 1 or 1 -> 0) for now
// Successful Shoot and Dribble and Run and Pass completed
// At each timestep (by time hidden variable), only one zone will take action
// The process always goes from Zone# -> Zone#Actions -> Zone#Team#Actions -> Loop Back
// Zone#: Guard against zones with no players and time over
// Zone#Actions: Choose what team gets to take actions in the zone#
// Zone#Team#Actions: Team# actual actions in Zone#
// Loop Back: Choose which Zone# gets to be active

#import "PAT.Lib.SoccerStateHelper";

#define timeOver time == 0;

var teamInPossessionOfBall:{0..1} = 0;
var ballInZone:{0..1} = 0;
var numOfTeam0PlayersInZone[2] = [2,0];
var numOfTeam1PlayersInZone[2] = [0,2];
var score = [0, 0];
var time = 20;

// ========== Soccer Match ========== //
// Main game
PlayGame = KickOff; (TickTock);

// ========== Utils Process ========== //
// Starting kickoff can be either team
KickOff = pcase {
	1: team0kickoff{teamInPossessionOfBall = 0; ballInZone=0;} -> Skip
	1: team1kickoff{teamInPossessionOfBall = 1; ballInZone=1;} -> Skip
};

// Decrement time and let a single zone perform an action
TickTock = timed{time--} -> ([]i:{0..1} @ Zone(i));

// Reset player positions
ResetPlayerPositions = resetpositions{
	numOfTeam0PlayersInZone[0]=2; 
	numOfTeam0PlayersInZone[1]=0; 
	numOfTeam1PlayersInZone[0]=0; 
	numOfTeam1PlayersInZone[1]=2;
} -> Skip;

// ========== Zone ========== //
Zone(zoneNum) = 
[call(canZoneAct, numOfTeam0PlayersInZone[zoneNum] + numOfTeam1PlayersInZone[zoneNum], time)] ([] teamNum:{0..1} @ Actions(zoneNum, teamNum)); TickTock // Perform an action for a zone that can act
[] 
[timeOver] Skip; // End if time is over

Actions(zoneNum, teamNum) = 
[call(canTeamZoneAct, teamNum, zoneNum, teamInPossessionOfBall, ballInZone, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone)] pcase {
		call(shootActionRate, teamNum, zoneNum, teamInPossessionOfBall, ballInZone):                                                     Shoot(teamNum, zoneNum)
		call(dribbleActionRate, teamNum, zoneNum, teamInPossessionOfBall, ballInZone, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone): Dribble(zoneNum, teamNum)
//		1: ZoneTeamPass(zoneNum, teamNum)
		call(runActionRate, teamNum, zoneNum, teamInPossessionOfBall, ballInZone, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone):     Run(zoneNum, teamNum)
};


// ############################# //
// ========== Actions ========== //
// ############################# //

// ========== Shoots =========== //
// Success:	Increment score, switch possession, reset player pos
ShootSuccess(teamNum) = shootSuccess.teamNum{
	score[teamNum]++; 
	if (teamNum == 0) {
		teamInPossessionOfBall = 1;
		ballInZone=1;
	} else {
		teamInPossessionOfBall = 0;
		ballInZone=0;
	}
} -> ResetPlayerPositions;

// Fail: Switch possession, start ball at opponent goal zone
ShootFail(teamNum) = shootSuccess.teamNum{
	if (teamNum == 0) {
		teamInPossessionOfBall = 1;
		ballInZone=1;
	} else {
		teamInPossessionOfBall = 0;
		ballInZone=0;
	}
} -> ResetPlayerPositions;

Shoot(teamNum, zoneNum) =
if (teamNum == 0) {
	pcase {
		call(shootSuccessRate): ShootSuccess(teamNum)
		call(shootFailRate):    ShootFail(teamNum) 
	}
} else {
	pcase {
		call(shootSuccessRate): ShootSuccess(teamNum)
		call(shootFailRate):    ShootFail(teamNum) 
	}
};

// ========== Dribble ========== //
// Success:	advance ball to next zone, advance one player to next zone
DribbleSuccess(teamNum, zoneNum) = dribbleSuccess.teamNum{
	if(teamNum == 0) {
		ballInZone++;
		numOfTeam0PlayersInZone[zoneNum]--;
		numOfTeam0PlayersInZone[zoneNum+1]++;
	} else {
		ballInZone--;
		numOfTeam1PlayersInZone[zoneNum]--; 
		numOfTeam1PlayersInZone[zoneNum-1]++;
	}
} -> Skip;

// Fail: switch possession
DribbleFail(teamNum, zoneNum) = dribbleSuccess.teamNum{
	if(teamNum == 0) {
		teamInPossessionOfBall = 1;
	} else {
		teamInPossessionOfBall = 0;
	}
} -> Skip;

Dribble(teamNum, zoneNum) =
if (teamNum == 0) {
	pcase {
		call(dribbleSuccessRate):                                                                  DribbleSuccess(teamNum, zoneNum)
		call(dribbleFailRate, teamNum, zoneNum, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone): DribbleFail(teamNum, zoneNum) 
	}
} else {
	pcase {
		call(dribbleSuccessRate):                                                                  DribbleSuccess(teamNum, zoneNum)
		call(dribbleFailRate, teamNum, zoneNum, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone): DribbleFail(teamNum, zoneNum) 
	}
};

//// ========== Pass ========== //
//// Success:	if there exists team member in next zone then advance ball to next zone, else pass to team member in this zone
//// Fail:	switch possession
//Team0passSuccess(zoneNum) 	= [doesTeam0HavePlayersInZone1] team0passSuccess{ballInZone=1;} -> TickTock [] TickTock;
//Team0passFail(zoneNum)		= team0passFail{teamInPossessionOfBall=1;} -> TickTock;
//Team1passSuccess(zoneNum)	= [doesTeam1HavePlayersInZone0] team1passSuccess{ballInZone=0;} -> TickTock [] TickTock;
//Team1passFail(zoneNum) 		= team1passFail{teamInPossessionOfBall=0;} -> TickTock;
//
//Team0pass(zoneNum) = pcase {
//	1:Team0passSuccess(zoneNum)
//	1:Team0passFail(zoneNum)
//};
//
//Team1pass(zoneNum) = pcase {
//	1:Team1passSuccess(zoneNum)
//	1:Team1passFail(zoneNum)
//};

// =========== Run ============ //
Run(zoneNum, teamNum) =
runSuccess.teamNum.zoneNum {
	if (teamNum == 0) {
		numOfTeam0PlayersInZone[zoneNum]--;
		numOfTeam0PlayersInZone[zoneNum+1]++;
	} else {
		numOfTeam1PlayersInZone[zoneNum]--;
		numOfTeam1PlayersInZone[zoneNum-1]++;
	}
} -> Skip;

// ========== Verifications ========== //
#define team0Win score[0] > score[1] && timeOver;
#define team1Win score[0] < score[1] && timeOver;
#define draw     score[0] == score[0] && timeOver;

#assert PlayGame deadlockfree;
#assert PlayGame reaches team0Win with prob;
#assert PlayGame reaches team1Win with prob;
#assert PlayGame reaches draw with prob;
#assert PlayGame reaches timeOver with prob;