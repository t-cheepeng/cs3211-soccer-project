// TODO List (In order of priority, Highest -> Lowest):
// 1. Have some C# Helper class to check all the defined things. ABSTRACTION
// 2. Model failures of shoot, dribble, run and pass
// 3. Model backward actions 
// 4. Assign probabilities to success/failure. Probably do this with a C# Helper class again
// 5. Expand to larger number of zones and larger number of players

// Model
// =============================
// |             |             |             
// |      0      |      1      |
// |             |             |
// =============================
// Instead of modelling players, we model zones on the field
// Each zone can have any number of players from either team
// Two Players only
// No goalkeeper
// Players are not allowed to perform actions backwards(ie. all actions move in one direction, from 0 -> 1 or 1 -> 0) for now
// Successful Shoot and Dribble and Run and Pass completed
// At each timestep (by time hidden variable), only one zone will take action
// The process always goes from Zone# -> Zone#Actions -> Zone#Team#Actions -> Loop Back
// Zone#: Guard against zones with no players and time over
// Zone#Actions: Choose what team gets to take actions in the zone#
// Zone#Team#Actions: Team# actual actions in Zone#
// Loop Back: Choose which Zone# gets to be active

#define timeOver time == 0;

#define isTeam0InPossession teamInPossessionOfBall == 0;
#define isTeam1InPossession teamInPossessionOfBall == 1;

#define doesTeam0HaveBallInZone0 isTeam0InPossession && ballInZone == 0; 
#define doesTeam0HavePlayersInZone0 numOfTeam0PlayersInZone[0] > 0;
#define doesTeam0HaveMoreThanOnePlayerInZone0 numOfTeam0PlayersInZone[0] > 1;
#define doesTeam0HaveBallInZone1 isTeam0InPossession && ballInZone == 1;
#define doesTeam0HavePlayersInZone1 numOfTeam0PlayersInZone[1] > 0;

#define doesTeam1HaveBallInZone0 isTeam1InPossession && ballInZone == 0; 
#define doesTeam1HavePlayersInZone0 numOfTeam1PlayersInZone[0] > 0;
#define doesTeam1HaveBallInZone1 isTeam1InPossession && ballInZone == 1;
#define doesTeam1HavePlayersInZone1 numOfTeam1PlayersInZone[1] > 0;
#define doesTeam1HaveMoreThanOnePlayerInZone1 numOfTeam1PlayersInZone[1] > 1;

// Some player must be in a zone and time not over in order for the zone to be active
#define canZone0Act numOfTeam0PlayersInZone[0] + numOfTeam1PlayersInZone[0] > 0 && !timeOver;
#define canZone1Act numOfTeam0PlayersInZone[1] + numOfTeam1PlayersInZone[1] > 0 && !timeOver;

var teamInPossessionOfBall:{0..1} = 0;
var ballInZone:{0..1} = 0;
var numOfTeam0PlayersInZone[2] = [2,0];
var numOfTeam1PlayersInZone[2] = [0,2];
var team0Score = 0;
var team1Score = 0;
hvar time = 75;

// ========== Success and Failure Choices ========== //
// ========== Shoots ========== //
// Success:	Increment score, switch possession, reset player pos
// Fail:	Switch possession, reset player pos
Team0shootSuccess 	= team0shootSuccess{team0Score++; teamInPossessionOfBall=1; ballInZone=1;} -> ResetPlayerPositions;
Team0shootFail 		= team0shootFail{teamInPossessionOfBall=1;} -> ResetPlayerPositions;
Team1shootSuccess 	= team1shootSuccess{team1Score++; teamInPossessionOfBall=0; ballInZone=0;} -> ResetPlayerPositions;
Team1shootFail 		= team1shootFail{teamInPossessionOfBall=0;} -> ResetPlayerPositions;

Zone0team0shoot = pcase	{
	1:Team0shootSuccess
	1:Team0shootFail // should be higher since shooting from afar
};
Zone1team0shoot = pcase	{
	1:Team0shootSuccess
	1:Team0shootFail
};
Zone0team1shoot = pcase	{
	1:Team1shootSuccess
	1:Team1shootFail
};
Zone1team1shoot = pcase	{
	1:Team1shootSuccess
	1:Team1shootFail // should be higher since shooting from afar
};

// ========== Dribble ========== //
// Success:	advance ball to next zone, advance one player to next zone
// Fail:	switch possession
Team0dribbleSuccess = team0dribbleSuccess{ballInZone=1; numOfTeam0PlayersInZone[0]--; numOfTeam0PlayersInZone[1]++;} -> TickTock;
Team0dribbleFail 	= team0dribbleFail{teamInPossessionOfBall=1;} -> TickTock;
Team1dribbleSuccess = team1dribbleSuccess{ballInZone=0; numOfTeam1PlayersInZone[0]++; numOfTeam0PlayersInZone[0]--;} -> TickTock;
Team1dribbleFail 	= team1dribbleFail{teamInPossessionOfBall=0;} -> TickTock;

Zone0team0dribble = pcase {
	1:Team0dribbleSuccess
	1:Team0dribbleFail
};

Zone1team1dribble = pcase {
	1:Team1dribbleSuccess
	1:Team1dribbleFail
};


// ========== Pass ========== //
// Success:	if there exists team member in next zone then advance ball to next zone, else pass to team member in this zone
// Fail:	switch possession
Team0passSuccess 	= [doesTeam0HavePlayersInZone1] team0passSuccess{ballInZone=1;} -> TickTock [] TickTock;
Team0passFail		= team0passFail{teamInPossessionOfBall=1;} -> TickTock;
Team1passSuccess	= [doesTeam1HavePlayersInZone0] team1passSuccess{ballInZone=0;} -> TickTock [] TickTock;
Team1passFail 		= team1passFail{teamInPossessionOfBall=0;} -> TickTock;

Zone0team0pass = pcase {
	1:Team0passSuccess
	1:Team0passFail
};

Zone1team1pass = pcase {
	1:Team1passSuccess
	1:Team1passFail
};

// ========== Run ========== //
Zone0team0run = [doesTeam0HavePlayersInZone0 && !doesTeam0HaveBallInZone0 || doesTeam0HaveMoreThanOnePlayerInZone0] 
				zone0team0run{numOfTeam0PlayersInZone[0]--; numOfTeam0PlayersInZone[1]++;} -> TickTock;
Zone1team1run = [doesTeam1HavePlayersInZone1 && !doesTeam1HaveBallInZone1 || doesTeam1HaveMoreThanOnePlayerInZone1] 
				zone1team1run{numOfTeam1PlayersInZone[0]++; numOfTeam1PlayersInZone[1]--;} -> TickTock;

// ========== Zone 0 ========== //
Zone0 = [canZone0Act] Zone0Actions [] [timeOver] Skip;
Zone0Actions = Zone0Team0Actions [] Zone0Team1Actions;

Zone0Team0Actions = 
	[doesTeam0HaveBallInZone0 && doesTeam0HavePlayersInZone0] pcase {
	1: Zone0team0shoot
	1: Zone0team0dribble
	1: Zone0team0pass
	}
	[] Zone0team0run;

Zone0Team1Actions = [doesTeam1HaveBallInZone0 && doesTeam1HavePlayersInZone0] pcase {
 	1: Zone0team1shoot
};


// ========== Zone 1 ========== //
Zone1 =  [canZone1Act] Zone1Actions [] [timeOver] Skip;
Zone1Actions = Zone1Team0Actions [] Zone1Team1Actions;

Zone1Team0Actions = [doesTeam0HaveBallInZone1 && doesTeam0HavePlayersInZone1] pcase {
	1: Zone1team0shoot
};

Zone1Team1Actions = [doesTeam1HaveBallInZone1 && doesTeam1HavePlayersInZone1] pcase {
	1: Zone1team1shoot
	1: Zone1team1dribble
	1: Zone1team1pass
	} 
	[] Zone1team1run;


// ========== Soccer Match ========== //
// Starting kickoff can be either team
Whokickoff = pcase {
	1: team0kickoff{teamInPossessionOfBall = 0; ballInZone=0;} -> Skip
	1: team1kickoff{teamInPossessionOfBall = 1; ballInZone=1;} -> Skip
};

//Whokickoff =
//	team0kickoff{teamInPossessionOfBall = 0; ballInZone=0;} -> Skip []
//	team1kickoff{teamInPossessionOfBall = 1; ballInZone=1;} -> Skip;

PlayGame = Whokickoff; (TickTock);
TickTock = timed{time--} -> (Zone0 [] Zone1);
ResetPlayerPositions = resetpositions{
							numOfTeam0PlayersInZone[0]=2; 
							numOfTeam0PlayersInZone[1]=0; 
							numOfTeam1PlayersInZone[0]=0; 
							numOfTeam1PlayersInZone[1]=2;
						} -> TickTock;


// ========== Verifications ========== //
#define team0Win team0Score > team1Score && timeOver;
#define team1Win team0Score < team1Score && timeOver;
#define draw team0Score == team1Score && timeOver;

#assert PlayGame reaches team0Win with prob;
#assert PlayGame reaches team1Win with prob;
#assert PlayGame reaches draw with prob;
#assert PlayGame reaches timeOver with prob;