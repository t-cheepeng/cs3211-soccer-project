// TODO List (In order of priority, Highest -> Lowest):
// 1. Have some C# Helper class to check all the defined things. ABSTRACTION
// 2. Model failures of shoot, dribble, run and pass
// 3. Model backward actions 
// 4. Assign probabilities to success/failure. Probably do this with a C# Helper class again
// 5. Expand to larger number of zones and larger number of players

// Model
// =============================
// |             |             |             
// |      0      |      1      |
// |             |             |
// =============================
// Instead of modelling players, we model zones on the field
// Each zone can have any number of players from either team
// Two Players only
// No goalkeeper
// Players are not allowed to perform actions backwards(ie. all actions move in one direction, from 0 -> 1 or 1 -> 0) for now
// Successful Shoot and Dribble and Run and Pass completed
// At each timestep (by time hidden variable), only one zone will take action
// The process always goes from Zone# -> Zone#Actions -> Zone#Team#Actions -> Loop Back
// Zone#: Guard against zones with no players and time over
// Zone#Actions: Choose what team gets to take actions in the zone#
// Zone#Team#Actions: Team# actual actions in Zone#
// Loop Back: Choose which Zone# gets to be active

#import "PAT.Lib.SoccerStateHelper";

#define timeOver time == 0;
#define N_X 4; // Forward-backward axis
#define N_Y 3; // Sideway axis

hvar team0StartFormation[N_X][N_Y] = [
	0, 3, 0,
	0, 2, 0,
	1, 1, 1,
	0, 2, 0
];
hvar team1StartFormation[N_X][N_Y] = [
	0, 1, 0,
	1, 1, 1,
	0, 2, 0,
	0, 3, 0
];

var teamInPossessionOfBall:{0..1} = 0;
var ballPosX:{0..N_X-1} = 0;
var ballPosY:{0..N_Y-1} = 0;
var numOfTeam0PlayersInZone[N_X][N_Y] = [
	0, 3, 0,
	0, 2, 0,
	1, 1, 1,
	0, 2, 0
];
var numOfTeam1PlayersInZone[N_X][N_Y] = [
	0, 1, 0,
	1, 1, 1,
	0, 2, 0,
	0, 3, 0
];
var score = [0, 0];
var time = 10;

// ========== Soccer Match ========== //
// Main game
PlayGame = KickOff; (TickTock);

// ========== Utils Process ========== //
// Starting kickoff can be either team
KickOff = pcase {
	1: kickOff.0{teamInPossessionOfBall = 0; ballPosX = 0;   ballPosY = 1;} -> Skip
	1: kickOff.1{teamInPossessionOfBall = 1; ballPosX = N_X-1; ballPosY = 1;} -> Skip
};

// Decrement time and let a single zone perform an action
TickTock = tau{time--} -> ([]x:{0..N_X-1};y:{0..N_Y-1} @ Zone(x, y));

// Reset player positions
ResetPlayerPositions = reset{
	numOfTeam0PlayersInZone[0][0] = team0StartFormation[0][0];
	numOfTeam0PlayersInZone[0][1] = team0StartFormation[0][1];
	numOfTeam0PlayersInZone[0][2] = team0StartFormation[0][2];
	numOfTeam0PlayersInZone[1][0] = team0StartFormation[1][0];
	numOfTeam0PlayersInZone[1][1] = team0StartFormation[1][1];
	numOfTeam0PlayersInZone[1][2] = team0StartFormation[1][2];
	numOfTeam0PlayersInZone[2][0] = team0StartFormation[2][0];
	numOfTeam0PlayersInZone[2][1] = team0StartFormation[2][1];
	numOfTeam0PlayersInZone[2][2] = team0StartFormation[2][2];
	numOfTeam0PlayersInZone[3][0] = team0StartFormation[3][0];
	numOfTeam0PlayersInZone[3][1] = team0StartFormation[3][1];
	numOfTeam0PlayersInZone[3][2] = team0StartFormation[3][2];

	numOfTeam1PlayersInZone[0][0] = team1StartFormation[0][0];
	numOfTeam1PlayersInZone[0][1] = team1StartFormation[0][1];
	numOfTeam1PlayersInZone[0][2] = team1StartFormation[0][2];
	numOfTeam1PlayersInZone[1][0] = team1StartFormation[1][0];
	numOfTeam1PlayersInZone[1][1] = team1StartFormation[1][1];
	numOfTeam1PlayersInZone[1][2] = team1StartFormation[1][2];
	numOfTeam1PlayersInZone[2][0] = team1StartFormation[2][0];
	numOfTeam1PlayersInZone[2][1] = team1StartFormation[2][1];
	numOfTeam1PlayersInZone[2][2] = team1StartFormation[2][2];
	numOfTeam1PlayersInZone[3][0] = team1StartFormation[3][0];
	numOfTeam1PlayersInZone[3][1] = team1StartFormation[3][1];
	numOfTeam1PlayersInZone[3][2] = team1StartFormation[3][2];
} -> Skip;

// ========== Zone ========== //
Zone(zoneX, zoneY) = 
[call(canZoneAct, numOfTeam0PlayersInZone[zoneX][zoneY] + numOfTeam1PlayersInZone[zoneX][zoneY], time)] ([] teamNum:{0..1} @ Actions(teamNum, zoneX, zoneY)); TickTock // Perform an action for a zone that can act
[] 
[timeOver] Skip; // End if time is over

Actions(teamNum, zoneX, zoneY) = 
[call(canTeamZoneAct, teamNum, zoneX, zoneY, teamInPossessionOfBall, ballPosX, ballPosY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone)] pcase {
	call(shootActionRate,   teamNum, zoneX, zoneY, teamInPossessionOfBall, ballPosX, ballPosY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone) : Shoot(teamNum, zoneX, zoneY)
	call(dribbleActionRate, teamNum, zoneX, zoneY, teamInPossessionOfBall, ballPosX, ballPosY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone) : Dribble(teamNum, zoneX, zoneY)
	call(passActionRate,    teamNum, zoneX, zoneY, teamInPossessionOfBall, ballPosX, ballPosY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone) : Pass(teamNum, zoneX, zoneY)
	call(runActionRate,     teamNum, zoneX, zoneY, teamInPossessionOfBall, ballPosX, ballPosY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone) : Run(teamNum, zoneX, zoneY)
};



// ############################# //
// ========== Actions ========== //
// ############################# //

// ========== Shoots =========== //
Shoot(teamNum, zoneX, zoneY) = pcase {
	call(shootSuccessRate): ShootSuccess(teamNum, zoneX, zoneY)
	call(shootFailRate)   : ShootFail(teamNum, zoneX, zoneY) 
};

// Success:	Increment score, switch possession, reset player pos
ShootSuccess(teamNum, zoneX, zoneY) = shootSuccess.teamNum.zoneX.zoneY{
	score[teamNum]++; 
	if (teamNum == 0) {
		teamInPossessionOfBall = 1;
		ballPosX = N_X - 1;
		ballPosY = 1;
	} else {
		teamInPossessionOfBall = 0;
		ballPosX = 0;
		ballPosY = 1;
	}
} -> ResetPlayerPositions;

// Fail: Switch possession, start ball at opponent goal zone
ShootFail(teamNum, zoneX, zoneY) = shootFail.teamNum.zoneX.zoneY{
	if (teamNum == 0) {
		teamInPossessionOfBall = 1;
		ballPosX = N_X - 1;
		ballPosY = 1;
	} else {
		teamInPossessionOfBall = 0;
		ballPosX = 0;
		ballPosY = 1;
	}
} -> Skip;



// ========== Dribble ========== //
// Can dribble forward or backward
Dribble(teamNum, zoneX, zoneY) = 
	DribbleTo(teamNum, zoneX, zoneY, zoneX+1, zoneY) [] 
	DribbleTo(teamNum, zoneX, zoneY, zoneX-1, zoneY) []
	DribbleTo(teamNum, zoneX, zoneY, zoneX, zoneY+1) [] 
	DribbleTo(teamNum, zoneX, zoneY, zoneX, zoneY-1);
DribbleTo(teamNum, zoneX, zoneY, toZoneX, toZoneY) = [call(canDribbleToZone, teamNum, zoneX, zoneY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone, toZoneX, toZoneY)] pcase {
	call(dribbleSuccessRate)                                                                        : DribbleSuccess(teamNum, zoneX, zoneY, toZoneX, toZoneY)
	call(dribbleFailRate,   teamNum, zoneX, zoneY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone): DribbleFail(teamNum, zoneX, zoneY, toZoneX, toZoneY) 
};

// Success:	advance ball to toZone, advance one player to toZone
DribbleSuccess(teamNum, zoneX, zoneY, toZoneX, toZoneY) = dribbleSuccess.teamNum.zoneX.zoneY.toZoneX.toZoneY{
	ballPosX = toZoneX;
	ballPosY = toZoneY;
	if(teamNum == 0) {
		numOfTeam0PlayersInZone[zoneX][zoneY]--;
		numOfTeam0PlayersInZone[toZoneX][toZoneY]++;
	} else {
		numOfTeam1PlayersInZone[zoneX][zoneY]--;
		numOfTeam1PlayersInZone[toZoneX][toZoneY]++;
	}
} -> Skip;

// Fail: switch possession
DribbleFail(teamNum, zoneX, zoneY, toZoneX, toZoneY) = dribbleFail.teamNum.zoneX.zoneY.toZoneX.toZoneY{
	if(teamNum == 0) {
		teamInPossessionOfBall = 1;
	} else {
		teamInPossessionOfBall = 0;
	}
} -> Skip;



// ========== Pass ========== //
// Can pass to any other zone with teammate
Pass(teamNum, zoneX, zoneY) = [] toZoneX:{0..N_X-1};toZoneY:{0..N_Y-1} @ PassTo(teamNum, zoneX, zoneY, toZoneX, toZoneY);
PassTo(teamNum, zoneX, zoneY, toZoneX, toZoneY) = [call(canPassToZone, teamNum, zoneX, zoneY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone, toZoneX, toZoneY)] pcase {
	call(passSuccessRate)                                                                        : PassSuccess(teamNum, zoneX, zoneY, toZoneX, toZoneY)
	call(passFailRate,   teamNum, zoneX, zoneY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone): PassFail(teamNum, zoneX, zoneY, toZoneX, toZoneY) 
};

// Success: ball position change
PassSuccess(teamNum, zoneX, zoneY, toZoneX, toZoneY) = passSuccess.teamNum.zoneX.zoneY.toZoneX.toZoneY{
	ballPosX = toZoneX;
	ballPosY = toZoneY;
} -> Skip;

// Fail: switch possession
PassFail(teamNum, zoneX, zoneY, toZoneX, toZoneY) = passFail.teamNum.zoneX.zoneY.toZoneX.toZoneY{
	if(teamNum == 0) {
		teamInPossessionOfBall = 1;
	} else {
		teamInPossessionOfBall = 0;
	}
} -> Skip;



// =========== Run ============ //
// Can run forward or backward
Run(teamNum, zoneX, zoneY) = 
	RunTo(teamNum, zoneX, zoneY, zoneX+1, zoneY) [] 
	RunTo(teamNum, zoneX, zoneY, zoneX-1, zoneY) []
	RunTo(teamNum, zoneX, zoneY, zoneX, zoneY+1) []
	RunTo(teamNum, zoneX, zoneY, zoneX, zoneY-1);
RunTo(teamNum, zoneX, zoneY, toZoneX, toZoneY) = [call(canRunToZone, teamNum, zoneX, zoneY, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone, toZoneX, toZoneY)] runSuccess.teamNum.zoneX.zoneY {
	if (teamNum == 0) {
		numOfTeam0PlayersInZone[zoneX][zoneY]--;
		numOfTeam0PlayersInZone[toZoneX][toZoneY]++;
	} else {
		numOfTeam1PlayersInZone[zoneX][zoneY]--;
		numOfTeam1PlayersInZone[toZoneX][toZoneY]++;
	}
} -> Skip;

// ========== Verifications ========== //
#define team0Win timeOver && score[0] > score[1] ;
#define team1Win timeOver && score[0] < score[1];
#define draw     timeOver && score[0] == score[0];

#assert PlayGame deadlockfree;
#assert PlayGame reaches team0Win with prob;
#assert PlayGame reaches team1Win with prob;
#assert PlayGame reaches draw with prob;
#assert PlayGame reaches timeOver with prob;