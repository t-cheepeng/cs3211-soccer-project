// TODO List (In order of priority, Highest -> Lowest):
// 1. Have some C# Helper class to check all the defined things. ABSTRACTION
// 2. Model failures of shoot, dribble, run and pass
// 3. Model backward actions 
// 4. Assign probabilities to success/failure. Probably do this with a C# Helper class again
// 5. Expand to larger number of zones and larger number of players

// Model
// =============================
// |             |             |             
// |      0      |      1      |
// |             |             |
// =============================
// Instead of modelling players, we model zones on the field
// Each zone can have any number of players from either team
// Two Players only
// No goalkeeper
// Players are not allowed to perform actions backwards(ie. all actions move in one direction, from 0 -> 1 or 1 -> 0) for now
// Successful Shoot and Dribble and Run and Pass completed
// At each timestep (by time hidden variable), only one zone will take action
// The process always goes from Zone# -> Zone#Actions -> Zone#Team#Actions -> Loop Back
// Zone#: Guard against zones with no players and time over
// Zone#Actions: Choose what team gets to take actions in the zone#
// Zone#Team#Actions: Team# actual actions in Zone#
// Loop Back: Choose which Zone# gets to be active

#import "PAT.Lib.SoccerStateHelper";

#define timeOver time == 0;

#define isTeam0InPossession teamInPossessionOfBall == 0;
#define isTeam1InPossession teamInPossessionOfBall == 1;

#define doesTeam0HaveBallInZone0 isTeam0InPossession && ballInZone == 0; 
#define doesTeam0HavePlayersInZone0 numOfTeam0PlayersInZone[0] > 0;
#define doesTeam0HaveMoreThanOnePlayerInZone0 numOfTeam0PlayersInZone[0] > 1;
#define doesTeam0HaveBallInZone1 isTeam0InPossession && ballInZone == 1;
#define doesTeam0HavePlayersInZone1 numOfTeam0PlayersInZone[1] > 0;

#define doesTeam1HaveBallInZone0 isTeam1InPossession && ballInZone == 0; 
#define doesTeam1HavePlayersInZone0 numOfTeam1PlayersInZone[0] > 0;
#define doesTeam1HaveBallInZone1 isTeam1InPossession && ballInZone == 1;
#define doesTeam1HavePlayersInZone1 numOfTeam1PlayersInZone[1] > 0;
#define doesTeam1HaveMoreThanOnePlayerInZone1 numOfTeam1PlayersInZone[1] > 1;

var teamInPossessionOfBall:{0..1} = 0;
var ballInZone:{0..1} = 0;
var numOfTeam0PlayersInZone[2] = [2,0];
var numOfTeam1PlayersInZone[2] = [0,2];
var team0Score = 0;
var team1Score = 0;
hvar time = 3;

// ========== Success and Failure Choices ========== //
// ========== Shoots ========== //
// Success:	Increment score, switch possession, reset player pos
// Fail:	Switch possession, reset player pos
Team0shootSuccess 	= team0shootSuccess{team0Score++; teamInPossessionOfBall=1; ballInZone=1;} -> ResetPlayerPositions;
Team0shootFail 		= team0shootFail{teamInPossessionOfBall=1;} -> ResetPlayerPositions;
Team1shootSuccess 	= team1shootSuccess{team1Score++; teamInPossessionOfBall=0; ballInZone=0;} -> ResetPlayerPositions;
Team1shootFail 		= team1shootFail{teamInPossessionOfBall=0;} -> ResetPlayerPositions;

Zone0team0shoot = pcase	{
	1:Team0shootSuccess
	1:Team0shootFail // should be higher since shooting from afar
};
Zone1team0shoot = pcase	{
	1:Team0shootSuccess
	1:Team0shootFail
};
Zone0team1shoot = pcase	{
	1:Team1shootSuccess
	1:Team1shootFail
};
Zone1team1shoot = pcase	{
	1:Team1shootSuccess
	1:Team1shootFail // should be higher since shooting from afar
};

// ========== Dribble ========== //
// Success:	advance ball to next zone, advance one player to next zone
// Fail:	switch possession
Team0dribbleSuccess = team0dribbleSuccess{ballInZone=1; numOfTeam0PlayersInZone[0]--; numOfTeam0PlayersInZone[1]++;} -> TickTock;
Team0dribbleFail 	= team0dribbleFail{teamInPossessionOfBall=1;} -> TickTock;
Team1dribbleSuccess = team1dribbleSuccess{ballInZone=0; numOfTeam1PlayersInZone[0]++; numOfTeam0PlayersInZone[0]--;} -> TickTock;
Team1dribbleFail 	= team1dribbleFail{teamInPossessionOfBall=0;} -> TickTock;

Zone0team0dribble = pcase {
	1:Team0dribbleSuccess
	1:Team0dribbleFail
};

Zone1team1dribble = pcase {
	1:Team1dribbleSuccess
	1:Team1dribbleFail
};


// ========== Pass ========== //
// Success:	if there exists team member in next zone then advance ball to next zone, else pass to team member in this zone
// Fail:	switch possession
Team0passSuccess 	= [doesTeam0HavePlayersInZone1] team0passSuccess{ballInZone=1;} -> TickTock [] TickTock;
Team0passFail		= team0passFail{teamInPossessionOfBall=1;} -> TickTock;
Team1passSuccess	= [doesTeam1HavePlayersInZone0] team1passSuccess{ballInZone=0;} -> TickTock [] TickTock;
Team1passFail 		= team1passFail{teamInPossessionOfBall=0;} -> TickTock;

Zone0team0pass = pcase {
	1:Team0passSuccess
	1:Team0passFail
};

Zone1team1pass = pcase {
	1:Team1passSuccess
	1:Team1passFail
};

ZoneTeamShoot(zoneNum, teamNum) = if (zoneNum == 0) { if (teamNum == 0) {Zone0team0shoot} else {Zone0team1shoot} } else { if (teamNum == 0) {Zone1team0shoot} else {Zone1team1shoot} };
ZoneTeamDribble(zoneNum, teamNum) = if (zoneNum == 0) { if (teamNum == 0) {Zone0team0dribble} } else  {Zone1team1dribble} ;
ZoneTeamPass(zoneNum, teamNum) = if (zoneNum == 0) { if (teamNum == 0) {Zone0team0pass} } else {Zone1team1pass};
ZoneTeamRun(zoneNum, teamNum) = [call(canZoneTeamRun, zoneNum, teamNum, teamInPossessionOfBall, ballInZone, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone)] 
	zoneTeamRun.zoneNum.teamNum {
		if (teamNum == 0) {
			numOfTeam0PlayersInZone[zoneNum]--;
			numOfTeam0PlayersInZone[zoneNum+1]++;
		} else {
			numOfTeam1PlayersInZone[zoneNum]--;
			numOfTeam1PlayersInZone[zoneNum-1]++;
		}
	} -> TickTock;

ZoneTeamActions(zoneNum, teamNum) = [call(doesTeamHaveBallInZone, teamNum, zoneNum, teamInPossessionOfBall, ballInZone) && call(doesTeamHavePlayersInZone, teamNum, zoneNum, numOfTeam0PlayersInZone, numOfTeam1PlayersInZone)] pcase {
		1: ZoneTeamShoot(zoneNum, teamNum)
		1: ZoneTeamDribble(zoneNum, teamNum)
		1: ZoneTeamPass(zoneNum, teamNum)
	 }
	 [] ZoneTeamRun(zoneNum, teamNum);
ZoneActions(zoneNum) = [] teamNum:{0..1} @ ZoneTeamActions(zoneNum, teamNum);
Zone(i) = [call(canZoneAct, numOfTeam0PlayersInZone[i] + numOfTeam1PlayersInZone[i], time)] ZoneActions(i) [] [timeOver] Skip;


// ========== Soccer Match ========== //
// Starting kickoff can be either team
Whokickoff = pcase {
	1: team0kickoff{teamInPossessionOfBall = 0; ballInZone=0;} -> Skip
	1: team1kickoff{teamInPossessionOfBall = 1; ballInZone=1;} -> Skip
};

PlayGame = Whokickoff; (TickTock);
TickTock = timed{time--} -> ([]i:{0..1} @ Zone(i));
ResetPlayerPositions = resetpositions{
							numOfTeam0PlayersInZone[0]=2; 
							numOfTeam0PlayersInZone[1]=0; 
							numOfTeam1PlayersInZone[0]=0; 
							numOfTeam1PlayersInZone[1]=2;
						} -> TickTock;


// ========== Verifications ========== //
#define team0Win team0Score > team1Score && timeOver;
#define team1Win team0Score < team1Score && timeOver;
#define draw team0Score == team1Score && timeOver;

#assert PlayGame deadlockfree;
#assert PlayGame reaches team0Win with prob;
#assert PlayGame reaches team1Win with prob;
#assert PlayGame reaches draw with prob;
#assert PlayGame reaches timeOver with prob;